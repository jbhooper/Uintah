/*
 * 2ProcessNiAlDiffusion.cc
 *
 *  Created on: Jan 25, 2019
 *      Author: jbhooper
 */

#include <CCA/Components/MPM/Diffusion/DiffusionModels/EAM_AlNi_Diffusion.h>
#include <CCA/Components/MPM/Diffusion/DiffusionModels/2ProcessNiAlDiffusion.h>
#include <CCA/Components/MPM/ConstitutiveModel/MPMMaterial.h>
#include <vector>

#include <CCA/Components/MPM/Diffusion/FunctionInterpolators/FunctionInterpolatorFactory.h>
#include <CCA/Components/MPM/Diffusion/FunctionInterpolators/FunctionInterpolator.h>

namespace Uintah {

  NiAl2Process::NiAl2Process(
                              ProblemSpecP      & probSpec
                            , SimulationStateP  & simState
                            , MPMFlags          * mpmFlag
                            , std::string         diff_type
                            )
                            : ScalarDiffusionModel(probSpec,
                                                   simState,
                                                   mpmFlag,
                                                   diff_type)
  {
    const double lowTFactor = 1000.0;
    probSpec->getWithDefault("scaleMultiplier", m_multiplier, 1.0);
    probSpec->getWithDefault("normalized", f_isConcNormalized, true);
    probSpec->require("D0_Liquid", m_D0Liquid);
    probSpec->getWithDefault("D0_Solid", m_D0Solid, 0.0);
    probSpec->getWithDefault("D0_LowT",m_D0LowT, m_D0Liquid/lowTFactor);
    probSpec->getWithDefault("Low_Temp_Al",m_lowT_Al, 933);
    probSpec->getWithDefault("Low_Temp_Ni",m_lowT_Ni, 1728);
    probSpec->getWithDefault("Use_old_model_low_temp",m_lowTOldModel, false);
    probSpec->getWithDefault("Melt_fraction_for_liquid_diffusivity",m_criticalMeltFraction, 0.9999);
    if (m_criticalMeltFraction > 0.9999) m_criticalMeltFraction = 0.9999;

    ProblemSpecP interpPS = probSpec->findBlock("function_interp");
    if (!interpPS) {
      throw ProblemSetupException("Diffusion type " + diff_type +
                                  " MUST include a function_interp block.",
                                  __FILE__, __LINE__);
    }

    m_phaseInterpolator = FunctionInterpolatorFactory::create(interpPS, simState, mpmFlag);

    m_globalMinNiConc = VarLabel::create("globalMinNiConc",min_vartype::getTypeDescription());
    m_globalMinAlConc = VarLabel::create("globalMinAlConc",min_vartype::getTypeDescription());
    m_pRegionType = VarLabel::create("p.regionTypeEnumIndex",ParticleVariable<int>::getTypeDescription());
    m_pRegionType_preReloc = VarLabel::create("p.regionTypeEnumIndex+", ParticleVariable<int>::getTypeDescription());
    m_pDiffusionCoefficient = VarLabel::create("p.diffusionCoefficient", ParticleVariable<double>::getTypeDescription());

    m_copypMeltLabel = VarLabel::find("p.meltProgress");
  }

  NiAl2Process::~NiAl2Process()
  {
    VarLabel::destroy(m_globalMinNiConc);
    VarLabel::destroy(m_globalMinAlConc);
    VarLabel::destroy(m_pRegionType);
    VarLabel::destroy(m_pRegionType_preReloc);
    VarLabel::destroy(m_pDiffusionCoefficient);

    delete m_phaseInterpolator;
  }

  void NiAl2Process::addInitialComputesAndRequires(       Task        * task
                                                  , const MPMMaterial * matl
                                                  , const PatchSet    * patches
                                                  ) const
  {
    const MaterialSubset  * matlset = matl->thisMaterial();
    task->computes(d_lb->pFluxLabel, matlset);
    // The region type actually requires pConcentration, but because of the way
    //   this initialization is called, it's not listed as a requirement, since
    //   its compute step is flat in the heirarchy with this step.
    task->computes(m_pRegionType, matlset);
    task->computes(m_globalMinNiConc, matlset);
    task->computes(m_globalMinAlConc, matlset);
  }

  void NiAl2Process::addParticleState(
                                        std::vector<const VarLabel*> &  from
                                     ,  std::vector<const VarLabel*> &  to
                                     ) const {
    from.push_back(d_lb->pFluxLabel);
    from.push_back(m_pRegionType);
    to.push_back(d_lb->pFluxLabel_preReloc);
    to.push_back(m_pRegionType_preReloc);
  }

  void NiAl2Process::scheduleComputeFlux(       Task        * task
                                        , const MPMMaterial * matl
                                        , const PatchSet    * patches
                                        ) const
  {
    const MaterialSubset  * matlSubset  = matl->thisMaterial();
    Ghost::GhostType        gnone       = Ghost::None;

    task->requires(Task::OldDW, d_lb->pConcGradientLabel, matlSubset, gnone);
    task->requires(Task::OldDW, d_lb->pTemperatureLabel,  matlSubset, gnone);
    task->requires(Task::OldDW, m_pRegionType,            matlSubset, gnone);
    task->requires(Task::OldDW, m_globalMinAlConc);
    task->requires(Task::OldDW, m_globalMinNiConc);
    task->requires(Task::OldDW, m_copypMeltLabel, matlSubset, gnone);

    task->computes(d_lb->pFluxLabel_preReloc, matlSubset);
    task->computes(m_pDiffusionCoefficient, matlSubset);
    task->computes(d_sharedState->get_delt_label(), getLevel(patches));
  }

  void NiAl2Process::computeFlux(
                                  const Patch         * patch
                                , const MPMMaterial   * matl
                                ,       DataWarehouse * old_dw
                                ,       DataWarehouse * new_dw
                                )
  {
    Vector dx     = patch->dCell();
    int    dwIdx  = matl->getDWIndex();

    constParticleVariable<double> pTemperature;
    constParticleVariable<double> pConcentration;
    constParticleVariable<Vector> pGradConcentration;
    constParticleVariable<int>    pRegionType;
    constParticleVariable<double> pMeltProgress;

    ParticleSubset* pSubset = old_dw->getParticleSubset(dwIdx, patch);

    old_dw->get(pGradConcentration, d_lb->pConcGradientLabel,   pSubset);
    old_dw->get(pTemperature,       d_lb->pTemperatureLabel,    pSubset);
    old_dw->get(pConcentration,     d_lb->pConcentrationLabel,  pSubset);
    old_dw->get(pMeltProgress,      m_copypMeltLabel,   		pSubset);
    old_dw->get(pRegionType,        m_pRegionType,              pSubset);

    ParticleVariable<double> pDiffusionCoefficient;
    new_dw->allocateAndPut(pDiffusionCoefficient, m_pDiffusionCoefficient, pSubset);

    ParticleVariable<Vector> pFluxNew;
    new_dw->allocateAndPut(pFluxNew, d_lb->pFluxLabel_preReloc, pSubset);

    size_t numParticles = pSubset->numParticles();
    if (numParticles == 0) return;

    double diffMax = -1e99;
    for (size_t pIdx = 0; pIdx < numParticles; ++pIdx) {
      double minConc;
      EAM_AlNi_Region regionType;
      if (pRegionType[pIdx] == EAM_AlNi_Region::NiRich) {
        regionType = EAM_AlNi_Region::NiRich;
        min_vartype minDiffusantConcentration;
        old_dw->get(minDiffusantConcentration, m_globalMinAlConc);
        minConc = minDiffusantConcentration;
      } else {
        regionType = EAM_AlNi_Region::AlRich;
        min_vartype minDiffusantConcentration;
        old_dw->get(minDiffusantConcentration, m_globalMinNiConc);
        minConc = minDiffusantConcentration;
      }
      const double & Temp = pTemperature[pIdx];
      const double & Conc = pConcentration[pIdx];
      const Vector & gradConc = pGradConcentration[pIdx];
      // For now, just ignore the minimum concentration crap.  JBH Fixme
      minConc = 0.0;
      double liquidMix = 0.0;
      if (pMeltProgress[pIdx] >= m_criticalMeltFraction) liquidMix = 1.0;
      double D = EAM_AlNi::Diffusivity(Temp,Conc,gradConc,minConc,regionType,
                                       m_phaseInterpolator,m_D0Liquid,m_D0Solid,m_D0LowT,
                                       m_lowTOldModel, m_lowT_Al, m_lowT_Ni, liquidMix)*m_multiplier;
      pDiffusionCoefficient[pIdx] = D;
      pFluxNew[pIdx] = D * pGradConcentration[pIdx];
      diffMax = std::max(diffMax, D);
    }
    // Because we know that the smallest timestep is when diffusivity is
    //   largest...
    double delT_local = computeStableTimeStep(diffMax,dx);
    if (delT_local < 1e-30) {
      std::cerr << "DelT local being poisoned in 2 ProcessNiAlDiffusion.cc  -- Value: " << delT_local << " diffMax: " << diffMax << "\n";
    }
    new_dw->put(delt_vartype(delT_local), d_lb->delTLabel, patch->getLevel());
  }

  void NiAl2Process::initializeSDMData( const Patch         * patch
                                      , const MPMMaterial   * matl
                                      ,       DataWarehouse * new_dw
                                      ) {
    ParticleVariable<Vector> pFlux;
    ParticleVariable<int>    pRegionType;

    double patchMinConcAl = 1e+10;
    double patchMinConcNi = 1e+10;

    const Vector fluxInitial(0.0);

    int dwIdx = matl->getDWIndex();
    ParticleSubset* pSubset = new_dw->getParticleSubset(dwIdx, patch);

    new_dw->allocateAndPut(pFlux, d_lb->pFluxLabel, pSubset);
    new_dw->allocateAndPut(pRegionType, m_pRegionType, pSubset);

    constParticleVariable<double> pConcentration;
    new_dw->get(pConcentration, d_lb->pConcentrationLabel, pSubset);

    for (ParticleSubset::iterator pIdx = pSubset->begin();
           pIdx < pSubset->end(); ++pIdx) {
      pFlux[*pIdx] = fluxInitial;
      // TODO:  This only works for normalized concentration; should fix for
      //         generalized concentration - 4-2019/JBH
      if (pConcentration[*pIdx] < 0.50) {
        pRegionType[*pIdx] = EAM_AlNi_Region::AlRich;
        patchMinConcNi = std::min(pConcentration[*pIdx],patchMinConcNi);
      }
      else {
        pRegionType[*pIdx] = EAM_AlNi_Region::NiRich;
        // If region is Ni rich and we're tracking normalized concentration of
        //   Ni, then C_Al is 1-C_Ni and track its minimum in Ni rich regions
        //   only.
        patchMinConcAl = std::min(1.0-pConcentration[*pIdx], patchMinConcAl);
      }
    }
    new_dw->put(min_vartype(patchMinConcAl),m_globalMinAlConc);
    new_dw->put(min_vartype(patchMinConcNi),m_globalMinNiConc);

  }

  void NiAl2Process::addSplitParticlesComputesAndRequires(
                                                                 Task        * task
                                                         , const MPMMaterial * matl
                                                         , const PatchSet    * patches
                                                         ) const {

  }

  void NiAl2Process::splitSDMSpecificParticleData(
                                                   const  Patch   * patch
                                                 , const  int       dwIdx
                                                 , const  int       nDims
                                                 ,        ParticleVariable<int> & pRefOld
                                                 ,        ParticleVariable<int> & pRef
                                                 , const  unsigned int            oldNumPart
                                                 , const  int                     numNewPart
                                                 ,        DataWarehouse         * old_dw
                                                 ,        DataWarehouse         * new_dw
                                                 ) {

  }

  void NiAl2Process::outputProblemSpec(ProblemSpecP  & ps
                                      ,bool            output_rdm_tag
                                      ) const
  {

    ProblemSpecP sdmPS = ps;
    if (output_rdm_tag) {
      sdmPS = ps->appendChild("diffusion_model");
      sdmPS->setAttribute("type",m_diffusionModelType);
      baseOutputSDMProbSpec(sdmPS, output_rdm_tag);
      sdmPS->appendElement("scaleMultiplier",m_multiplier);
      sdmPS->appendElement("normalized", f_isConcNormalized);
      sdmPS->appendElement("D0_Liquid", m_D0Liquid);
      sdmPS->appendElement("D0_Solid", m_D0Solid);
      sdmPS->appendElement("D0_LowT", m_D0LowT);
      sdmPS->appendElement("Low_Temp_Al",m_lowT_Al);
      sdmPS->appendElement("Low_Temp_Ni",m_lowT_Ni);
      sdmPS->appendElement("Use_old_model_low_temp",m_lowTOldModel);
      sdmPS->appendElement("Melt_fraction_for_liquid_diffusivity",m_criticalMeltFraction);


      m_phaseInterpolator->outputProblemSpec(sdmPS, output_rdm_tag);

    }
//    ProblemSpecP sdmPS = ps;
//    if (output_rdm_tag) {
//      sdmPS = ps->appendChild("diffusion_model");
//      sdmPS->setAttribute("type","eam_alni");
//    }
//      sdmPS->appendElement("diffusivity",d_D0);
//      sdmPS->appendElement("max_concentration",d_MaxConcentration);
//      sdmPS->appendElement("min_concentration",d_MinConcentration);
//      sdmPS->appendElement("conc_tolerance",d_concTolerance);
//      sdmPS->appendElement("scaleMultiplier",m_multiplier);
//      sdmPS->appendElement("normalized", f_isConcNormalized);
//      sdmPS->appendElement("D0_Liquid", m_D0Liquid);
//      sdmPS->appendElement("D0_Solid", m_D0Solid);
//      m_phaseInterpolator->outputProblemSpec(sdmPS, output_rdm_tag);


  }

  double NiAl2Process::getMaxConstClamp(const double & Temp) const {
    // Maps the maximum concentration between liquidus and solidus for the Al/Ni rich
    //   regions of the phase diagram to a fit analytic curve.  For systems
    //   where the liquidus of B2 AlNi is not exposed (i.e. other phases are
    //   encountered at 'earlier' concentrations, simulation has shown that
    //   we still approach the liquidus concentration of B2 before crystalizing
    //   below temperatures of about 1100K.  We will ignore multi-phase reactions
    //   below 1100K for now.

    EAM_AlNi_Region regionType = EAM_AlNi_Region::AlRich;
    //   For now we only return things in the Al rich region of the phase diagram
    //     (molePercentNi nominal < 0.50)
    return (EAM_AlNi::getSolidus(Temp, regionType));

  }

  void NiAl2Process::scheduleTrackConcentrationThreshold(       Task        * task
                                                        ,const  MPMMaterial * matl
                                                        ,const  PatchSet    * patchSet
                                                        ) const {
    {
        Ghost::GhostType gan = Ghost::AroundNodes;

        task->requires(Task::OldDW, m_pRegionType, gan, 0);

        task->requires(Task::NewDW, d_lb->pConcentrationLabel_preReloc, gan, 0);

        task->computes(m_globalMinAlConc);
        task->computes(m_globalMinNiConc);
        task->computes(m_pRegionType_preReloc, matl->thisMaterial());
        //, patchSubset, matlSubset);
    }

  }

  void NiAl2Process::trackConcentrationThreshold(const Patch          * patch
                                                ,const MPMMaterial    * matl
                                                ,      DataWarehouse  * old_dw
                                                ,      DataWarehouse  * new_dw  ) {

    int    dwIdx  = matl->getDWIndex();

    double localMinAlConc = 1.0e+10;
    double localMinNiConc = 1.0e+10;

    constParticleVariable<int> pRegionType;
    constParticleVariable<double> pConcentrationNew;

    ParticleSubset* pSubset = old_dw->getParticleSubset(dwIdx, patch);
    old_dw->get(pRegionType, m_pRegionType, pSubset);
    new_dw->get(pConcentrationNew, d_lb->pConcentrationLabel_preReloc, pSubset);

    ParticleVariable<int> pRegionType_Update;
    new_dw->allocateAndPut(pRegionType_Update, m_pRegionType_preReloc, pSubset);

    pRegionType_Update.copyData(pRegionType);
    for (size_t pIdx = 0; pIdx < pSubset->numParticles(); ++pIdx) {
      // Set the region type dependent upon the conentration:
      if (pConcentrationNew[pIdx] < 0.50) {
  //      pRegionType_Update[pIdx] = EAM_AlNi_Region::AlRich;
      } else {
  //      pRegionType_Update[pIdx] = EAM_AlNi_Region::NiRich;
      }
//      pRegionType_Update[pIdx] = pRegionType[pIdx];
      if (pRegionType[pIdx] == EAM_AlNi_Region::AlRich) {
        if (pConcentrationNew[pIdx] < localMinNiConc) {
          localMinNiConc = pConcentrationNew[pIdx];
        }
      } else if (pRegionType[pIdx] == EAM_AlNi_Region::AlRich) {
          double C_Al = 1.0-pConcentrationNew[pIdx];
          if (C_Al < localMinAlConc) {
            localMinAlConc = C_Al;
          }
      }
    }
    new_dw->put(min_vartype(localMinAlConc),m_globalMinAlConc);
    new_dw->put(min_vartype(localMinNiConc),m_globalMinNiConc);
  }

} // namespace Uintah
